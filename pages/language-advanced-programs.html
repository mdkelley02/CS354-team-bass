<!DOCTYPE html>
<html lang="en">

  <head>
    <meta charset="UTF-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Advanced Programs</title>
    <!-- highlight.js theme -->
    <link
      rel="stylesheet"
      href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.3.1/styles/base16/atelier-savanna.min.css"
      integrity="sha512-iIJWR1qiBpEbiTqcERO1RH5DS3YsRlGvm5mEa/S54GwrGmvMmYwiDGNao5XSUtPxs0U7BnbMre8H3UtiHTO9lg=="
      crossorigin="anonymous"
      referrerpolicy="no-referrer"
    />
    <!-- Poppins Font -->
    <link
      rel="stylesheet"
      href="https://fonts.googleapis.com/css?family=Poppins"
    />
    <!-- Ubuntu Mono Font -->
    <link
      rel="stylesheet"
      href="https://fonts.googleapis.com/css?family=Ubuntu+Mono"
    />
    <!-- Boostrap grid -->
    <link
      rel="stylesheet"
      href="https://cdn.jsdelivr.net/npm/bootstrap-v4-grid-only@1.0.0/dist/bootstrap-grid.min.css"
    />
    <!-- global styling -->
    <link
      rel="stylesheet"
      href="../styles/index.css"
    />
  </head>


  <body>
    <div class="container">
      <h1>Advanced Programs</h1>
      <hr>


      <h2>Build and Run Instructions (For All Programs)</h2>
      <ol>
        <li>Ensure all dependencies for your platform are installed by following these instructions <a href="./pages/language-translators.html">here.</a></li>
        <li>Copy one of the desired programs below into a file with a .rs extension. For example, <strong>linked_list.rs</strong>.</li>
        <li>From the command line, ensure you are in the directory of the copied program, then run the following commands:</li>
      </ol>
      <p>(Windows)</p>
      <pre><code class="language-shell">
        $ rustc your_program_name.rs
        $ your_program_name.exe
      </code></pre>
      <p>(Mac & Linux)</p>
      <pre><code class="language-shell">
        $ rustc your_program_name.rs
        $ ./your_program_name
      </code></pre>
      <hr>


      <h2>Linked List</h2>
      <h4><i>(Author: Taylor Brooks)</i></h4>
      <p>Running the below program will output the following:</p>
      <p class="mono">
        2 added to list<br>
        3 added to list<br>
        3 removed from list.<br>
        4 added to list<br>
        head:4,2,1:tail
      </p>
      <pre><code class="language-rust">
        #[derive(Clone,PartialEq)]
        struct Node {
            value: i32,
            next: Option&#60Box&#60Node>>,
        }

        impl Node {
            fn new_node(value: i32) -> Node {
                Node{value: value, next: None}
            }
        }

        #[derive(Clone)]
        struct List {
            head: Option&#60Box&#60Node>>,
        }

        impl List {
            fn new_list() -> List {
                List{head: None}
            }

            fn put_on_head(&mut self, value: i32) {
                let mut new_node: Box&#60Node> = Box::new(Node::new_node(value));
                match self.head {
                    Some(ref _node) => {
                        new_node.next = self.head.clone();
                        self.head = Some(new_node);
                    }
                    None => {
                        self.head = Some(new_node);
                        return;
                    }
                }
                println!("{} added to list", value);
            }

            fn get_from_head(&mut self) -> i32 {
                match self.head {
                    Some(ref node) => {
                        let temp_node = node.clone();
                        self.head = node.next.clone();
                        return temp_node.value;
                    }
                    None => {
                        panic!("Cannot get from empty list!");

                    }
                }
            }

            fn print_list(self) {
                match self.head {
                    Some(ref node) => {
                        print!("head:{}", node.value);
                        let mut temp_node = node;
                        while temp_node.next != None {
                            match temp_node.next {
                                Some(ref next) => {
                                    print!(",{}", next.value);
                                    temp_node = next;
                                }
                                None => {}
                            }
                        }
                        println!(":tail");
                    },
                    None => {println!("Empty List!")}
                }
            }
        }

        fn main() {
            let mut list = List::new_list();
            list.put_on_head(1);
            list.put_on_head(2);
            list.put_on_head(3);
            println!("{} removed from list.", list.get_from_head());
            list.put_on_head(4);
            list.print_list();
        }
      </code></pre>
      <hr>


      <h2>Bank (from la2)</h2>
      <h4><i>(Author: Cory Tomlinson)</i></h4>
      <p>Running this program will output the following:</p>
      <p class="mono">
        01001:Ann:100.00<br>
        01002:Ann:204.00<br>
      </p>
      <pre><code class="language-rust">
        #![allow(dead_code)] //for unused methods, like Account.deposit()

        use std::fmt::{Display,Formatter,Result};

        // ---------- Customer ---------------------------------------------------------------------

        pub struct Customer {
           name:String
        }

        impl Display for Customer {
           fn fmt(&self, f:&mut Formatter<'_>) -> Result {
              write!(f,"{}",self.name)
           }
        }

        // ---------- Account ----------------------------------------------------------------------

        pub enum AccountType {
           Checking,
           Saving
        }

        pub struct Account<'a> {
           acct_type:AccountType,
           number:String,
           customer:&'a Customer,
           balance:f64,
           interest:f64
        }

        impl Account<'_> {
           fn accrue(&mut self, rate:f64) {
              match self.acct_type {
                 AccountType::Checking => {},
                 AccountType::Saving => {
                    self.interest += self.balance*rate;
                    self.balance += self.balance*rate;
                 }
              }
           }
           fn balance(&self) -> f64 {self.balance}
           fn deposit(&mut self, amount:f64) {self.balance += amount;}
           fn withdraw(&mut self, amount:f64) {self.balance -= amount;}
        }

        impl Display for Account<'_> {
           fn fmt(&self, f:&mut Formatter<'_>) -> Result {
              write!(f,"{}:{}:{:.2}",self.number,self.customer,self.balance)
           }
        }

        // ---------- Bank -------------------------------------------------------------------------

        pub struct Bank<'a> {
           accounts:Vec<&'a mut Account<'a>>
        }

        impl<'a> Bank<'a> {
           fn add(&mut self, account:&'a mut Account<'a>) {
              self.accounts.push(account);
           }
           fn accrue(&mut self, rate:f64) {
              for account in self.accounts.iter_mut() {
                 account.accrue(rate);
              }
           }
        }

        impl Display for Bank<'_> {
           fn fmt(&self, f:&mut Formatter<'_>) -> Result {
              for account in self.accounts.iter() {
                 writeln!(f,"{}",account)?;
              }
              Ok(())
           }
        }

        // ---------- main -------------------------------------------------------------------------

        fn main() {
           let mut bank = Bank {accounts: Vec::new()};
           let c = Customer {name: String::from("Ann")};
           let mut account1 = Account {
              acct_type: AccountType::Checking,
              number: String::from("01001"),
              customer: &c,
              balance: 100.00,
              interest: 0.00
           };
           let mut account2 = Account {
              acct_type: AccountType::Saving,
              number: String::from("01002"),
              customer: &c,
              balance: 200.00,
              interest: 0.00
           };
           bank.add(&mut account1);
           bank.add(&mut account2);
           bank.accrue(0.02);
           println!("{}",bank);
        }
      </code></pre>
      <hr>


      <h2>File Management: Read/Write</h2>
      <h4><i>(Author: Senami Hodonu)</i></h4>
      <p>Running this program will output the following:</p>
      <p class="mono">
        TBD line1<br>
        TBD line2<br>
        TBD etc...<br>
      </p>
      <pre><code class="language-rust">
        use std::fs::File; //file struct
        use std::io::{prelude::*, BufReader}; //Helps with the read and write operations
        use std::env;
        extern crate regex;
        use regex::Regex;
        
        /**
         * Program exploring reading from/writing to a file and a little bit of regular 
         * expressions in Rust.
         */
        fn main() {
            //Program takes in commandline arguments
            //read, write or regex
            let args: Vec&ltString> = env::args().collect();
            println!("{:?}", args);
            let command = &args[1];
        
            println!("{}  option selected", command);
            println!();
        
            if command.eq("read"){
                //read from a file
                let mut file = File::open("src/main.rs").expect("Can't open file!");
                let mut contents = String::new();
                file.read_to_string(&mut contents).expect("File not available");
                println!("File Contents:\n\n{}", contents);
        
                for cap in Regex::new(r"\d{1,4}").unwrap().find_iter(&contents) {
                    println!("{:#?}", cap.as_str());
                }
        
            } else if command.eq("write") {
                //Writing to a file
                let mut file = File::create("output.txt").expect("Could not open file");
              
                let reader = BufReader::new(File::open("test.txt").expect("Cannot open file.txt"));
        
                for line in reader.lines() {
                    for word in line.unwrap().split_whitespace() {
                        println!("word '{}'", word);
                        let mut owned: String = word.to_owned();
                        owned.push_str(" "); //String concatenation
                        file.write_all(owned.as_bytes()).expect("Cannot write to file");
                    }
                }
        
            } else if command.eq("regex"){
                //regular expression catching digits with max length of 4
                let mut file = File::open("src/main.rs").expect("Can't open file!");
                let mut contents = String::new();
                file.read_to_string(&mut contents).expect("File not available");
                println!("File Contents:\n\n{}", contents);
        
                for cap in Regex::new(r"\d{1,4}").unwrap().find_iter(&contents) {
                    //The r in front of our regular expression makes it so that excape sequences are 
                    //not needed!
                    println!("{:#?}", cap.as_str());
                }   
            }
        }
      </code></pre>
      <hr>


      <h2>TBD Example 4</h2>
      <h4><i>(Author: TBD)</i></h4>
      <p>Running this program will output the following:</p>
      <p class="mono">
        TBD line1<br>
        TBD line2<br>
        TBD etc...<br>
      </p>
      <pre><code class="language-rust">
        fn main() {
           println!("hello world");
        }
      </code></pre>
      <hr>


      <h2>TBD Example 5</h2>
      <h4><i>(Author: TBD)</i></h4>
      <p>Running this program will output the following:</p>
      <p class="mono">
        TBD line1<br>
        TBD line2<br>
        TBD etc...<br>
      </p>
      <pre><code class="language-rust">
        fn main() {
           println!("hello world");
        }
      </code></pre>
      <hr>


      <h2>TBD Example 6</h2>
      <h4><i>(Author: TBD)</i></h4>
      <p>Running this program will output the following:</p>
      <p class="mono">
        TBD line1<br>
        TBD line2<br>
        TBD etc...<br>
      </p>
      <pre><code class="language-rust">
        fn main() {
           println!("hello world");
        }
      </code></pre>
      <hr>
    </div>
  </body>


  <footer>
    <!-- highlight.js -->
    <script
      src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.4.0/highlight.min.js"
      integrity="sha512-IaaKO80nPNs5j+VLxd42eK/7sYuXQmr+fyywCNA0e+C6gtQnuCXNtORe9xR4LqGPz5U9VpH+ff41wKs/ZmC3iA=="
      crossorigin="anonymous"
      referrerpolicy="no-referrer"
    ></script>
    <script defer src="../scripts/includeHighlights.js"></script>
  </footer>

</html>
